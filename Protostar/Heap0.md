# Heap Zero Writeup

# `Source Code`

![source code](img/heap/heap0_source_code.png)

Bu soruda basitçe `heap overflow`'un ne olduğunu ve kod akışını nasıl etkileyebileceğimizi göreceğiz. Amacımız kullanılmayan `winner` fonksiyonunu çalıştırmak olacak.

`gdb` ile belleğimizin düzenine bir göz atalım. Burada `main()` işlevimiz dönmeden hemen öncesine bir `breakpoint` atayacağız.

![0](img/heap/heap0_0.png)

Evet şimdi de `info proc map` komutu ile `heap`'imizin başladığı adresi bulalım.

![1](img/heap/heap0_1.png)

Girmiş olduğumuz `AAAA` karakterleri `Heap`'de nerede bir de onlara bakalım

![2](img/heap/heap0_2.png)

`nowinner` fonksiyonumuzun `heap` üzerinde depolandığını görüyoruz. Hemen onunda adresine bakalım. (f->fp = nowinner)

![3](img/heap/heap0_3.png)

`f->fp()` tarafından yürütülecek olan adresin üzerine `winner()` adresimizi yazabiliriz. Bunun için `64+8` byte yazdıktan sonra `winner()` adresimizi yazacağız.

![4](img/heap/heap0_4.png)

Gördüğünüz gibi 72 karakterden sonra yazdığımız `CCCC`'nin adresleri geldi. Şimdi `winner` adresimizi öğrenip bunun yerine yazabiliriz.

![5](img/heap/heap0_5.png)

![6](img/heap/heap0_6.png)

![7](img/heap/heap0_7.png)

Ve bu level ' i de başarıyla geçmiş olduk.

NOT : 64'ten sonra yazdığımız 8 byte, `prev_size` ve `malloc_chunk` yapısının boyutunu temsil ediyor.
